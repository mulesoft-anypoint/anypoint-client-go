/*
Exchange Apps

Description of the Exchange Apps API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package exchange_apps

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiDeleteExchangeClientAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	appId int32
}

func (r DefaultApiDeleteExchangeClientAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExchangeClientAppExecute(r)
}

/*
DeleteExchangeClientApp Delete Exchange Client Apps

Delete Exchange Client Apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @param appId The ID of the Exchange App
 @return DefaultApiDeleteExchangeClientAppRequest
*/
func (a *DefaultApiService) DeleteExchangeClientApp(ctx context.Context, orgId string, appId int32) DefaultApiDeleteExchangeClientAppRequest {
	return DefaultApiDeleteExchangeClientAppRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		appId: appId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteExchangeClientAppExecute(r DefaultApiDeleteExchangeClientAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteExchangeClientApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{orgId}/applications/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetExchangeClientApps400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v DeleteExchangeClientApp404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiGetExchangeClientAppContractsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	appId int32
	includeContractsForApiVersion *int32
}

// This field is used to filter by API version
func (r DefaultApiGetExchangeClientAppContractsRequest) IncludeContractsForApiVersion(includeContractsForApiVersion int32) DefaultApiGetExchangeClientAppContractsRequest {
	r.includeContractsForApiVersion = &includeContractsForApiVersion
	return r
}

func (r DefaultApiGetExchangeClientAppContractsRequest) Execute() ([]GetExchangeAppContractsResponseInner, *http.Response, error) {
	return r.ApiService.GetExchangeClientAppContractsExecute(r)
}

/*
GetExchangeClientAppContracts Get Exchange Client Application Contracts

Get Exchange Client Application Contracts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @param appId The ID of the Exchange App
 @return DefaultApiGetExchangeClientAppContractsRequest
*/
func (a *DefaultApiService) GetExchangeClientAppContracts(ctx context.Context, orgId string, appId int32) DefaultApiGetExchangeClientAppContractsRequest {
	return DefaultApiGetExchangeClientAppContractsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
		appId: appId,
	}
}

// Execute executes the request
//  @return []GetExchangeAppContractsResponseInner
func (a *DefaultApiService) GetExchangeClientAppContractsExecute(r DefaultApiGetExchangeClientAppContractsRequest) ([]GetExchangeAppContractsResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetExchangeAppContractsResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetExchangeClientAppContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{orgId}/applications/{appId}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeContractsForApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeContractsForApiVersion", r.includeContractsForApiVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetExchangeClientApps400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetExchangeClientAppsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	targetAdminSite *bool
	query *string
	offset *int32
	limit *int32
}

// MUST be set to true in order to get the Client ID and Secret. Without this query parameter, the same call will return all the Client Applications but not the Client ID and Secret (and other info).
func (r DefaultApiGetExchangeClientAppsRequest) TargetAdminSite(targetAdminSite bool) DefaultApiGetExchangeClientAppsRequest {
	r.targetAdminSite = &targetAdminSite
	return r
}

// Filter results that matches the input
func (r DefaultApiGetExchangeClientAppsRequest) Query(query string) DefaultApiGetExchangeClientAppsRequest {
	r.query = &query
	return r
}

// The offset specifies the offset of the first row to return
func (r DefaultApiGetExchangeClientAppsRequest) Offset(offset int32) DefaultApiGetExchangeClientAppsRequest {
	r.offset = &offset
	return r
}

// Amount of objects retrieved in the response
func (r DefaultApiGetExchangeClientAppsRequest) Limit(limit int32) DefaultApiGetExchangeClientAppsRequest {
	r.limit = &limit
	return r
}

func (r DefaultApiGetExchangeClientAppsRequest) Execute() ([]GetExchangeAppsResponseInner, *http.Response, error) {
	return r.ApiService.GetExchangeClientAppsExecute(r)
}

/*
GetExchangeClientApps Read Exchange Client Apps

Read All or partial Exchange Client Apps. If you need to get all the available exchange apps on your organization (not just the client apps created by the user making the Query). You need to use this call with your Master Org id, a bearer token for an Admin user, and the query parameter 'targetAdminSite' set to 'true'. This call will return every application (with pagination if more than the set limit) for this particular Anypoint Account.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @return DefaultApiGetExchangeClientAppsRequest
*/
func (a *DefaultApiService) GetExchangeClientApps(ctx context.Context, orgId string) DefaultApiGetExchangeClientAppsRequest {
	return DefaultApiGetExchangeClientAppsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return []GetExchangeAppsResponseInner
func (a *DefaultApiService) GetExchangeClientAppsExecute(r DefaultApiGetExchangeClientAppsRequest) ([]GetExchangeAppsResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetExchangeAppsResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetExchangeClientApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{orgId}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.targetAdminSite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetAdminSite", r.targetAdminSite, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetExchangeClientApps400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiPostExchangeClientAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	orgId string
	apiInstanceId *string
	postExchangeAppsBody *PostExchangeAppsBody
}

// The API Manager Instance Id
func (r DefaultApiPostExchangeClientAppRequest) ApiInstanceId(apiInstanceId string) DefaultApiPostExchangeClientAppRequest {
	r.apiInstanceId = &apiInstanceId
	return r
}

func (r DefaultApiPostExchangeClientAppRequest) PostExchangeAppsBody(postExchangeAppsBody PostExchangeAppsBody) DefaultApiPostExchangeClientAppRequest {
	r.postExchangeAppsBody = &postExchangeAppsBody
	return r
}

func (r DefaultApiPostExchangeClientAppRequest) Execute() (*PostExchangeAppsReponse, *http.Response, error) {
	return r.ApiService.PostExchangeClientAppExecute(r)
}

/*
PostExchangeClientApp Create a new Exchange Client App

Create a new Exchange Client App

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId The ID of the organization in GUID format
 @return DefaultApiPostExchangeClientAppRequest
*/
func (a *DefaultApiService) PostExchangeClientApp(ctx context.Context, orgId string) DefaultApiPostExchangeClientAppRequest {
	return DefaultApiPostExchangeClientAppRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return PostExchangeAppsReponse
func (a *DefaultApiService) PostExchangeClientAppExecute(r DefaultApiPostExchangeClientAppRequest) (*PostExchangeAppsReponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostExchangeAppsReponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PostExchangeClientApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{orgId}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiInstanceId", r.apiInstanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postExchangeAppsBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetExchangeClientApps400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
