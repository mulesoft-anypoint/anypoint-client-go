/*
Deployment v1

The Application Manager API exists to provide Mule Application management operations from Anypoint Control Planes to any Runtime Plane, with capabilities that include:   - Deploying a Mule Application or API to a Mule Runtime   - Scaling up or down a running application   - Managing application settings (ie: properties)   - Deleting a Mule Application Deployment   - Changing artifact version or configurations of a deployment   - Starting, Stopping or Restarting applications   - etc. This API currently supports deployments to Cloudhub 1.0 targets only. 

API version: 1.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package application_manager_v1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiDeleteDeploymentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
	domain string
}

// The environment id where the application is deployed
func (r DefaultApiDeleteDeploymentRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiDeleteDeploymentRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the application is deployed
func (r DefaultApiDeleteDeploymentRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiDeleteDeploymentRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

func (r DefaultApiDeleteDeploymentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeploymentExecute(r)
}

/*
DeleteDeployment Delete a single application

Delete a single application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domain The application domain in the path
 @return DefaultApiDeleteDeploymentRequest
*/
func (a *DefaultApiService) DeleteDeployment(ctx context.Context, domain string) DefaultApiDeleteDeploymentRequest {
	return DefaultApiDeleteDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		domain: domain,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteDeploymentExecute(r DefaultApiDeleteDeploymentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDeployment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/v2/applications/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(parameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return nil, reportError("xAnypntOrgId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiGetAllDeploymentsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
}

// The environment id where the applications are deployed
func (r DefaultApiGetAllDeploymentsRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiGetAllDeploymentsRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the applications are deployed
func (r DefaultApiGetAllDeploymentsRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiGetAllDeploymentsRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

func (r DefaultApiGetAllDeploymentsRequest) Execute() (*GetAllDeploymentsResponse, *http.Response, error) {
	return r.ApiService.GetAllDeploymentsExecute(r)
}

/*
GetAllDeployments List deployments

Retrieves a list of deployments for the specified query. If the query returns no results, then an empty list is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiGetAllDeploymentsRequest
*/
func (a *DefaultApiService) GetAllDeployments(ctx context.Context) DefaultApiGetAllDeploymentsRequest {
	return DefaultApiGetAllDeploymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllDeploymentsResponse
func (a *DefaultApiService) GetAllDeploymentsExecute(r DefaultApiGetAllDeploymentsRequest) (*GetAllDeploymentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllDeploymentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllDeployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/armui/api/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return localVarReturnValue, nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return localVarReturnValue, nil, reportError("xAnypntOrgId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetCH1DeploymentsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
	retrieveStatistics *bool
	period *int64
	retrieveLogLevels *bool
	retrieveTrackingSettings *bool
	retrieveIpAddresses *bool
}

// The environment id where the application is deployed
func (r DefaultApiGetCH1DeploymentsRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiGetCH1DeploymentsRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the application is deployed
func (r DefaultApiGetCH1DeploymentsRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiGetCH1DeploymentsRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

// Include statistics for each application in the response.
func (r DefaultApiGetCH1DeploymentsRequest) RetrieveStatistics(retrieveStatistics bool) DefaultApiGetCH1DeploymentsRequest {
	r.retrieveStatistics = &retrieveStatistics
	return r
}

// Number of milliseconds of statistics to gather.
func (r DefaultApiGetCH1DeploymentsRequest) Period(period int64) DefaultApiGetCH1DeploymentsRequest {
	r.period = &period
	return r
}

// Include log levels for each application in the response.
func (r DefaultApiGetCH1DeploymentsRequest) RetrieveLogLevels(retrieveLogLevels bool) DefaultApiGetCH1DeploymentsRequest {
	r.retrieveLogLevels = &retrieveLogLevels
	return r
}

// Include tracking settings for each application in the response.
func (r DefaultApiGetCH1DeploymentsRequest) RetrieveTrackingSettings(retrieveTrackingSettings bool) DefaultApiGetCH1DeploymentsRequest {
	r.retrieveTrackingSettings = &retrieveTrackingSettings
	return r
}

// Include ip address allocations for each application in the response.
func (r DefaultApiGetCH1DeploymentsRequest) RetrieveIpAddresses(retrieveIpAddresses bool) DefaultApiGetCH1DeploymentsRequest {
	r.retrieveIpAddresses = &retrieveIpAddresses
	return r
}

func (r DefaultApiGetCH1DeploymentsRequest) Execute() ([]DeploymentCH1Summary, *http.Response, error) {
	return r.ApiService.GetCH1DeploymentsExecute(r)
}

/*
GetCH1Deployments List Cloudhub1 deployments

Retrieves a list of Cloudhub1 deployments for the specified query. If the query returns no results, then an empty list is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiGetCH1DeploymentsRequest
*/
func (a *DefaultApiService) GetCH1Deployments(ctx context.Context) DefaultApiGetCH1DeploymentsRequest {
	return DefaultApiGetCH1DeploymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeploymentCH1Summary
func (a *DefaultApiService) GetCH1DeploymentsExecute(r DefaultApiGetCH1DeploymentsRequest) ([]DeploymentCH1Summary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeploymentCH1Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCH1Deployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/v2/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return localVarReturnValue, nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return localVarReturnValue, nil, reportError("xAnypntOrgId is required and must be specified")
	}

	if r.retrieveStatistics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveStatistics", r.retrieveStatistics, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.retrieveLogLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveLogLevels", r.retrieveLogLevels, "")
	}
	if r.retrieveTrackingSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveTrackingSettings", r.retrieveTrackingSettings, "")
	}
	if r.retrieveIpAddresses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrieveIpAddresses", r.retrieveIpAddresses, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetDeploymentCH1DetailsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
	domain string
}

// The environment id where the application is deployed
func (r DefaultApiGetDeploymentCH1DetailsRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiGetDeploymentCH1DetailsRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the application is deployed
func (r DefaultApiGetDeploymentCH1DetailsRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiGetDeploymentCH1DetailsRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

func (r DefaultApiGetDeploymentCH1DetailsRequest) Execute() (*DeploymentCH1Details, *http.Response, error) {
	return r.ApiService.GetDeploymentCH1DetailsExecute(r)
}

/*
GetDeploymentCH1Details Read deployment details

Retrieve a single application by name. Requires 'Read Applications' role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domain The application domain in the path
 @return DefaultApiGetDeploymentCH1DetailsRequest
*/
func (a *DefaultApiService) GetDeploymentCH1Details(ctx context.Context, domain string) DefaultApiGetDeploymentCH1DetailsRequest {
	return DefaultApiGetDeploymentCH1DetailsRequest{
		ApiService: a,
		ctx: ctx,
		domain: domain,
	}
}

// Execute executes the request
//  @return DeploymentCH1Details
func (a *DefaultApiService) GetDeploymentCH1DetailsExecute(r DefaultApiGetDeploymentCH1DetailsRequest) (*DeploymentCH1Details, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentCH1Details
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDeploymentCH1Details")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/v2/applications/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(parameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return localVarReturnValue, nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return localVarReturnValue, nil, reportError("xAnypntOrgId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetMuleVersionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r DefaultApiGetMuleVersionsRequest) Execute() (*RuntimeCollection, *http.Response, error) {
	return r.ApiService.GetMuleVersionsExecute(r)
}

/*
GetMuleVersions Read available mule versions

Read available mule versions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiGetMuleVersionsRequest
*/
func (a *DefaultApiService) GetMuleVersions(ctx context.Context) DefaultApiGetMuleVersionsRequest {
	return DefaultApiGetMuleVersionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RuntimeCollection
func (a *DefaultApiService) GetMuleVersionsExecute(r DefaultApiGetMuleVersionsRequest) (*RuntimeCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RuntimeCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMuleVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/mule-versions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiPostDeploymentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
	appInfoJson *string
	file *os.File
	autoStart *bool
}

// The environment id where the application is deployed
func (r DefaultApiPostDeploymentRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiPostDeploymentRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the application is deployed
func (r DefaultApiPostDeploymentRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiPostDeploymentRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

// A JSON string representing the deployment configuration. Look at \\\&quot;NewDeploymentStruct\\\&quot; for structure. 
func (r DefaultApiPostDeploymentRequest) AppInfoJson(appInfoJson string) DefaultApiPostDeploymentRequest {
	r.appInfoJson = &appInfoJson
	return r
}

// The Mule application artifact to be deployed.
func (r DefaultApiPostDeploymentRequest) File(file *os.File) DefaultApiPostDeploymentRequest {
	r.file = file
	return r
}

// Indicates whether the application should be automatically started after deployment.
func (r DefaultApiPostDeploymentRequest) AutoStart(autoStart bool) DefaultApiPostDeploymentRequest {
	r.autoStart = &autoStart
	return r
}

func (r DefaultApiPostDeploymentRequest) Execute() (*DeploymentCH1Details, *http.Response, error) {
	return r.ApiService.PostDeploymentExecute(r)
}

/*
PostDeployment Create a new deployment

Deploys a new Mule Application to Cloudhub (CH1).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiPostDeploymentRequest
*/
func (a *DefaultApiService) PostDeployment(ctx context.Context) DefaultApiPostDeploymentRequest {
	return DefaultApiPostDeploymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeploymentCH1Details
func (a *DefaultApiService) PostDeploymentExecute(r DefaultApiPostDeploymentRequest) (*DeploymentCH1Details, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentCH1Details
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PostDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/v2/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return localVarReturnValue, nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return localVarReturnValue, nil, reportError("xAnypntOrgId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	if r.appInfoJson != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "appInfoJson", r.appInfoJson, "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"


	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.autoStart != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoStart", r.autoStart, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiPutDeploymentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
	domain string
	appInfoJson *string
	file *os.File
}

// The environment id where the application is deployed
func (r DefaultApiPutDeploymentRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiPutDeploymentRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the application is deployed
func (r DefaultApiPutDeploymentRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiPutDeploymentRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

// A JSON string representing the deployment configuration. Look at \\\&quot;NewDeploymentStruct\\\&quot; for structure. 
func (r DefaultApiPutDeploymentRequest) AppInfoJson(appInfoJson string) DefaultApiPutDeploymentRequest {
	r.appInfoJson = &appInfoJson
	return r
}

// The Mule application artifact to be deployed.
func (r DefaultApiPutDeploymentRequest) File(file *os.File) DefaultApiPutDeploymentRequest {
	r.file = file
	return r
}

func (r DefaultApiPutDeploymentRequest) Execute() (*DeploymentCH1Details, *http.Response, error) {
	return r.ApiService.PutDeploymentExecute(r)
}

/*
PutDeployment Update a single application.

Update a single application. Requires 'Manage Settings' role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param domain The application domain in the path
 @return DefaultApiPutDeploymentRequest
*/
func (a *DefaultApiService) PutDeployment(ctx context.Context, domain string) DefaultApiPutDeploymentRequest {
	return DefaultApiPutDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		domain: domain,
	}
}

// Execute executes the request
//  @return DeploymentCH1Details
func (a *DefaultApiService) PutDeploymentExecute(r DefaultApiPutDeploymentRequest) (*DeploymentCH1Details, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentCH1Details
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/v2/applications/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(parameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return localVarReturnValue, nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return localVarReturnValue, nil, reportError("xAnypntOrgId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	if r.appInfoJson != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "appInfoJson", r.appInfoJson, "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"


	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiPutDeploymentsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	xAnypntEnvId *string
	xAnypntOrgId *string
	updateDeploymentBulkBody *UpdateDeploymentBulkBody
}

// The environment id where the application is deployed
func (r DefaultApiPutDeploymentsRequest) XAnypntEnvId(xAnypntEnvId string) DefaultApiPutDeploymentsRequest {
	r.xAnypntEnvId = &xAnypntEnvId
	return r
}

// The org id where the application is deployed
func (r DefaultApiPutDeploymentsRequest) XAnypntOrgId(xAnypntOrgId string) DefaultApiPutDeploymentsRequest {
	r.xAnypntOrgId = &xAnypntOrgId
	return r
}

// Application deployment body containing configuration and artifact file.
func (r DefaultApiPutDeploymentsRequest) UpdateDeploymentBulkBody(updateDeploymentBulkBody UpdateDeploymentBulkBody) DefaultApiPutDeploymentsRequest {
	r.updateDeploymentBulkBody = &updateDeploymentBulkBody
	return r
}

func (r DefaultApiPutDeploymentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutDeploymentsExecute(r)
}

/*
PutDeployments Updates deployment states in bulk

Bulk Action (UPDATE, START, STOP, RESTART, DELETE) for Applications. The threshold for number of domains in the bulk actions is 100. These actions cannot be stopped. Requires 'Manage Settings' role.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultApiPutDeploymentsRequest
*/
func (a *DefaultApiService) PutDeployments(ctx context.Context) DefaultApiPutDeploymentsRequest {
	return DefaultApiPutDeploymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) PutDeploymentsExecute(r DefaultApiPutDeploymentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutDeployments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudhub/api/v2/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAnypntEnvId == nil {
		return nil, reportError("xAnypntEnvId is required and must be specified")
	}
	if r.xAnypntOrgId == nil {
		return nil, reportError("xAnypntOrgId is required and must be specified")
	}
	if r.updateDeploymentBulkBody == nil {
		return nil, reportError("updateDeploymentBulkBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-env-id", r.xAnypntEnvId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anypnt-org-id", r.xAnypntOrgId, "")
	// body params
	localVarPostBody = r.updateDeploymentBulkBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
